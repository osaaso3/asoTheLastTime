@page "/cogmod"
@using System
@using System.Threading
@using System.Threading.Tasks
@inject HttpClient Http
@using System.Globalization
@inject IJSRuntime JSRuntime
@using System.Diagnostics
@inject NavigationManager navigationManager
@inject DataService dataService
@inject State state

@* 
@layout AsoLayout2

@inject Header header
        <Button id="add-habit" class="btn btn-lg btn-primary rounded-circle" @onclick="@(() => { asoPageA(); })"><span class="fa fa-fw fa-plus"></span></Button>

*@


<div class="row">
        <div class="nav flex-column">
        <RadzenTabs Change=@OnChange>
            <Tabs>       
                <RadzenTabsItem Text="Start">
        

<RadzenCard Style=" margin-bottom: 20px;">
    <div class="row">
         <div class="col-md-6">  

       <Pagination Class="m-0">

            @for (int i = 0; i < dataService.CategoryList.Count; ++i)
            {
                 int idx = i;
                   string index = i == 0 ? "None" : "Model " + i.ToString();//string index = i.ToString();
                string css = string.Empty;

                <PaginationItem Class="@css" Active="@(state.SelectedCategoryId == dataService.CategoryList[idx].Id)">
                    <PaginationLink Page="@(dataService.CategoryList[idx].Id.ToString())" Clicked="(Page) => { asoPageC(Page); }">
                        @index
                    </PaginationLink>
                </PaginationItem>
            }

        </Pagination>

  
        @if (1==1)//(asoNodes.Contains("target"))
{
  <RadzenCard Style="width:600px;">
    <RadzenButton Click=@(args => asoPageA()) Text="Start/Stop" Icon="label" Style="margin-bottom: 10px; width: 165px" />
    <RadzenChart Visible="trialsChart">

        <RadzenColumnSeries StrokeWidth="5" Data="@modelsRTarray" CategoryProperty="modelCycleX" Title="RTc" ValueProperty="modelRTc" />
        <RadzenColumnSeries StrokeWidth="5" Data="@modelsRTarray" CategoryProperty="modelCycleX" Title="RTi" ValueProperty="modelRTi" />
        <RadzenLineSeries Smooth="@smoothTrials" Data="@modelsRTarray" CategoryProperty="modelCycleX" Title="RTc-RTi" LineType="LineType.Solid" ValueProperty="modelRTic">
            <RadzenMarkers MarkerType="MarkerType.Circle" />
        </RadzenLineSeries>
        <RadzenColumnOptions Radius="5" />
        <RadzenValueAxis Formatter="@FormatAsUSD">
            <RadzenGridLines Visible="true" />
            <RadzenAxisTitle Text="Mean RT (ms)" />
        </RadzenValueAxis>
    </RadzenChart>
   </RadzenCard>
}
      
        
            @if (1==2)//asoHabit=="Priming")//            @if (dataService.HabitList[i].Description=="ISI")//asoIndex==2)
            // @for (int i=0;i<dataService.HabitList.Count;i++)
            //
             {                 
            <!-- Add the component -->
  
              }
              
            @if (1==2)//asoHabit=="Stroop")
              {                  
            <!-- Add the component -->
     
              }
    </div>

    <div class="col-md-6">
        @*
         <label>Trials Chart Visible<RadzenCheckBox @bind-Value="@trialsChart" Name="trials"></RadzenCheckBox></label>
        *@
@if (1==1)//asoNodes.Contains("priming"))
{
<RadzenCard Style="width:600px;">
    <RadzenChart Visible="trialsChart">
      <RadzenProgressBar @bind-Value="@mProgress" />
        <label>Smooth<RadzenCheckBox @bind-Value="@smoothTrials" Name="smooth"></RadzenCheckBox></label>
        <label>Model: @m / @ModelNumber Trial: @n / @TrialNumber </label>
        <RadzenLineSeries Smooth="@smoothTrials" Data="@trialsRTarray" CategoryProperty="trialCycleX" Title="RT" LineType="LineType.Solid" ValueProperty="trialRT">
            <RadzenMarkers MarkerType="MarkerType.Circle" />
        </RadzenLineSeries>
        <RadzenCategoryAxis Step="5" Padding="20" FormatString="{0}" />
        <RadzenValueAxis Formatter="@FormatAsUSD">
            <RadzenGridLines Visible="true" />
            <RadzenAxisTitle Text="Trial RT (ms)" />
        </RadzenValueAxis>
    </RadzenChart>
</RadzenCard>
}
    </div>

<div class="col-md-6">
@if (1==1)//(asoNodes.Contains("prime"))
{   
    <RadzenCard Style="width:600px;">
                          
    <RadzenChart Style="height: 400px;" Visible="singleTrialChartPrime">
        <label>Speed/Resolution: Min 1 <RadzenSlider @bind-Value="asoSingleTrialSpeed" TValue="int" Min="1" Max="N" Step="10" Change="@((args) => Change(args, "Slider from 1 to 100"))" Style="margin-bottom: 0px;" /> Max @N</label>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="L-Prime" LineType="LineType.Solid" ValueProperty="singleTrialOutbLLX">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="R-Prime" LineType="LineType.Solid" ValueProperty="singleTrialOutbLRX">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="L-Mask" LineType="LineType.Solid" ValueProperty="singleTrialOutbLMX">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenCategoryAxis Step="100" Padding="100" FormatString="{0}" />
        <RadzenValueAxis Formatter="@FormatAsUSD" Min="0" Max="1">
            <RadzenGridLines Visible="true" />
            <RadzenAxisTitle Text="Activation" />
        </RadzenValueAxis>
      </RadzenChart>
          </RadzenCard>

}



@if (1==1)//(asoNodes.Contains("target"))
{
     <RadzenCard Style="width:600px;">
                       
    <RadzenChart Style="height: 400px;" Visible="singleTrialChartTarget">
        <label>Speed/Resolution: Min 1 <RadzenSlider @bind-Value="asoSingleTrialSpeed" TValue="int" Min="1" Max="N" Step="10" Change="@((args) => Change(args, "Slider from 1 to 100"))" Style="margin-bottom: 0px;" /> Max @N</label>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="L-Target" LineType="LineType.Solid" ValueProperty="singleTrialOutbRLX">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="R-Target" LineType="LineType.Solid" ValueProperty="singleTrialOutbRRX">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="R-Mask" LineType="LineType.Solid" ValueProperty="singleTrialOutbRMX">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenCategoryAxis Step="100" Padding="100" FormatString="{0}" />
        <RadzenValueAxis Formatter="@FormatAsUSD" Min="0" Max="1">
            <RadzenGridLines Visible="true" />
            <RadzenAxisTitle Text="Activation" />
        </RadzenValueAxis>
    </RadzenChart>
        </RadzenCard>

}
 @if (1==1)//(asoNodes.Contains("response"))
{    
    <RadzenCard Style="width:600px;">

    <RadzenChart Style="height: 400px;" Visible="singleTrialChartResponse">
        <label>Speed/Resolution: Min 1 <RadzenSlider @bind-Value="asoSingleTrialSpeed" TValue="int" Min="1" Max="N" Step="10" Change="@((args) => Change(args, "Slider from 1 to 100"))" Style="margin-bottom: 0px;" /> Max @N</label>
        <RadzenLineSeries  Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="L-Response" LineType="LineType.Solid" ValueProperty="singleTrialOutaLX">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="R-Response" LineType="LineType.Solid" ValueProperty="singleTrialOutaRX">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="Threshold-R" LineType="LineType.Solid" ValueProperty="singleTrialOutaThresh">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenCategoryAxis Step="100" Padding="100" FormatString="{0}" />
        <RadzenValueAxis Formatter="@FormatAsUSD" Min="0" Max="1">
            <RadzenGridLines Visible="true" />
            <RadzenAxisTitle Text="Activation" />
        </RadzenValueAxis>
    </RadzenChart>
        </RadzenCard>

}
 </div>

 <div class="col-md-6">
@if (1==1)//(asoNodes.Contains("task"))
{     
    <RadzenCard Style="width:600px;">

    <RadzenChart Style="height: 400px;" Visible="singleTrialChartTask">
        <label>Speed/Resolution: Min 1 <RadzenSlider @bind-Value="asoSingleTrialSpeed" TValue="int" Min="1" Max="N" Step="10" Change="@((args) => Change(args, "Slider from 1 to 100"))" Style="margin-bottom: 0px;" /> Max @N</label>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="L-Task" LineType="LineType.Solid" ValueProperty="singleTrialTaskLX">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="R-Task" LineType="LineType.Solid" ValueProperty="singleTrialTaskRX">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="Threshold-T" LineType="LineType.Solid" ValueProperty="singleTrialTaskThresh">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenCategoryAxis Step="100" Padding="100" FormatString="{0}" />
        <RadzenValueAxis Formatter="@FormatAsUSD" Min="0" Max="1">
            <RadzenGridLines Visible="true" />
            <RadzenAxisTitle Text="Activation" />
        </RadzenValueAxis>
      </RadzenChart>
          </RadzenCard>

}

@if (1==1)//(asoNodes.Contains("attention"))
{  
    <RadzenCard Style="width:600px;">

    <RadzenChart Style="height: 400px;" Visible="singleTrialChartAttention">
        <label>Speed/Resolution: Min 1 <RadzenSlider @bind-Value="asoSingleTrialSpeed" TValue="int" Min="1" Max="N" Step="10" Change="@((args) => Change(args, "Slider from 1 to 100"))" Style="margin-bottom: 0px;" /> Max @N</label>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="V-Attention" LineType="LineType.Solid" ValueProperty="singleTrialAttV">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="U-Attention" LineType="LineType.Solid" ValueProperty="singleTrialAttU">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="HV-Attention" LineType="LineType.Solid" ValueProperty="singleTrialAttHv">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenCategoryAxis Step="100" Padding="100" FormatString="{0}" />
        <RadzenValueAxis Formatter="@FormatAsUSD" Min="0" Max="1">
            <RadzenGridLines Visible="true" />
            <RadzenAxisTitle Text="Activation" />
        </RadzenValueAxis>
    </RadzenChart>
        </RadzenCard>
}
 @if(1==1)//(asoNodes.Contains("conflict"))
{   
    <RadzenCard Style="width:600px;">

    <RadzenChart Style="height: 400px;" Visible="singleTrialChartConflict">
        <label>Speed/Resolution: Min 1 <RadzenSlider @bind-Value="asoSingleTrialSpeed" TValue="int" Min="1" Max="N" Step="10" Change="@((args) => Change(args, "Slider from 1 to 100"))" Style="margin-bottom: 0px;" /> Max @N</label>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="Conflict-1" LineType="LineType.Solid" ValueProperty="singleTrialConf">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="Conflict-T" LineType="LineType.Solid" ValueProperty="singleTrialConfThresh">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenLineSeries Smooth="@smoothTrial" Data="@singleTrialArray" CategoryProperty="singleTrialCycle" Title="Conflict-C" LineType="LineType.Solid" ValueProperty="singleTrialConfTrial">
            <RadzenMarkers MarkerType="MarkerType.Auto" />
        </RadzenLineSeries>
        <RadzenCategoryAxis Step="100" Padding="100" FormatString="{0}" />
        <RadzenValueAxis Formatter="@FormatAsUSD" Min="0" Max="1">
            <RadzenGridLines Visible="true" />
            <RadzenAxisTitle Text="Activation" />
        </RadzenValueAxis>
    </RadzenChart>
    </RadzenCard>

}

    </div>
  </div>
    </RadzenCard>



    </RadzenTabsItem>
                 
   <RadzenTabsItem Text="Settings">


  @if (dataService.Settings.ShowHelp)
{
    <div class="container-fluid px-1 px-sm-0 py-2 py-sm-3 d-flex flex-grow-1">
        <div id="overlay-parent" class="row mx-0 flex-grow-1">
            <div class="col-lg-12 col-xl-6 px-1 px-sm-3">
    <HelpComponent />
            </div>
        </div>
    </div>
}
else if (state.ShowOptions)
{
     <SettingsComponent />
}
else
{
    <div class="container-fluid px-1 px-sm-0 py-2 py-sm-3 d-flex flex-grow-1">
        <div id="overlay-parent" class="row mx-0 flex-grow-1">

            <div class="col-lg-12 col-xl-6 px-1 px-sm-3">

                <HabitComponent Pinned="true" />

                @if (dataService.Settings.ShowCategories)
                {
                    <CategoryComponent />
                }

                <HabitComponent />

                <div class="py-5"></div>

                <Button id="add-habit" class="btn btn-lg btn-primary rounded-circle" @onclick="@(() => { state.NewHabit(); })"><span class="fa fa-fw fa-plus"></span></Button>
            </div>

            <SelectedHabitComponent />
        </div>
    </div>
}

</RadzenTabsItem>
                <RadzenTabsItem Text="Multiple-Trial/Blocks Results">

  <RadzenCard Style="width:600px;">
     <label>Blocks Chart Visible<RadzenCheckBox @bind-Value="modelsChart" Name="models"></RadzenCheckBox></label>
    <RadzenChart Visible="modelsChart">
        <label>Smooth<RadzenCheckBox @bind-Value="@smoothModels" Name="smooth"></RadzenCheckBox></label>
        <RadzenColumnSeries StrokeWidth="5" Data="@modelsRTarray" CategoryProperty="modelCycleX" Title="RTc" ValueProperty="modelRTc" />
        <RadzenColumnSeries StrokeWidth="5" Data="@modelsRTarray" CategoryProperty="modelCycleX" Title="RTi" ValueProperty="modelRTi" />
        <RadzenLineSeries Smooth="@smoothModels" Data="@modelsRTarray" CategoryProperty="modelCycleX" Title="RTc-RTi" LineType="LineType.Solid" ValueProperty="modelRTic">
            <RadzenMarkers MarkerType="MarkerType.Circle" />
        </RadzenLineSeries>
        <RadzenColumnOptions Radius="5" />
        <RadzenValueAxis Formatter="@FormatAsUSD">
            <RadzenGridLines Visible="true" />
            <RadzenAxisTitle Text="Mean RT (ms)" />
        </RadzenValueAxis>
    </RadzenChart>
   </RadzenCard>

    <div class="col-xl-6">
        <RadzenFieldset AllowCollapse="true" Style="width:600px;margin-bottom: 20px; height:500px;"
                        Expand=@(() => Change("Fieldset expanded")) Collapse=@(() => Change("Fieldset collapsed"))>
            <HeaderTemplate>
                <span>
                    <RadzenIcon Icon="account_box" /><b style="font-size:30px">Model</b>
                     <RadzenNumeric Placeholder="PageSize" @bind-Value="@asoPageSize" />
                </span>
            </HeaderTemplate>
            <ChildContent>
                <RadzenDataList PageSize="@asoPageSize" WrapItems="true" AllowPaging="true"
                                Data="@modelsRTlist" TItem="modelDataItem">
                    <Template Context="order">
                        <RadzenCard Style="width:300px;height:300px">
                            <div class="row">
                                <div class="col-md-6">
                                    <div>Trial:</div>
                                    <b>@order.TrialsStr</b>
                                    <div style="margin-top:20px">Cycle/RT</div>
                                    <b>@(order.modelCycleX + " " + order.modelRTc)</b>
                                    <br />
                                </div>
                                <div class="col-md-6">
                                    <div style="margin-top:20px">Incongruent:</div>
                                    <b>@(order.modelRTi)</b>
                                    <div style="margin-top:20px">Congruent:</div>
                                    <b>@(order.modelRTc)</b>
                                </div>
                            </div>

                        </RadzenCard>
                    </Template>
                </RadzenDataList>
            </ChildContent>
        </RadzenFieldset>
    </div>

    </RadzenTabsItem>
        <RadzenTabsItem Text="Parameters">

    <RadzenCard Style="width:400px;">
    <p>Maina</p>
    <div class="mat-layout-grid">
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">                
            <RadzenNumeric Placeholder="ModelNumber" @bind-Value="@ModelNumber"></RadzenNumeric>ModelNumber
            </div>
            <div class="mat-layout-grid-cell">                
                <RadzenNumeric Placeholder="TrialNumber" @bind-Value="@TrialNumber"></RadzenNumeric>TrialNumber
            </div>
        </div>
    </div>
    </RadzenCard>
    
    <RadzenCard Style="width:400px;">
    <p>Duration</p>
    <div class="mat-layout-grid">
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">                
                <RadzenNumeric Placeholder="DurationTrial" @bind-Value="@N"></RadzenNumeric>DurationTrial
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="DurationFix" @bind-Value="@durFix" ></RadzenNumeric>DurationFix
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="DurationPrime" @bind-Value="@durPrime" ></RadzenNumeric>DurationPrime
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="DurationMask" @bind-Value="@durMask" ></RadzenNumeric>DurationMask
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="DurationTarget" @bind-Value="@durTarget" ></RadzenNumeric>DurationTarget
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="PrimeMaskISI" @bind-Value="@durPrimeMaskISI" ></RadzenNumeric>PrimeMaskISI
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="MaskTargetISI" @bind-Value="@durMaskTargetISI" ></RadzenNumeric>MaskTargetISI
            </div>
        </div>
    </div>

    <p>Noise</p>
    <div class="mat-layout-grid">
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="NoisePTM" @bind-Value="@noisePTR" ></RadzenNumeric>NoisePTM
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="NoiseMasks" @bind-Value="@noiseMasks" ></RadzenNumeric>NoiseMasks
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="NoiseTass" @bind-Value="@noiseTask" ></RadzenNumeric>NoiseTass
            </div>
        </div>
    </div>

    <p>Prime</p>
    <div class="mat-layout-grid">
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="CrossPri" @bind-Value="@CrossPri" ></RadzenNumeric>CrossPri
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="SelfPri" @bind-Value="@SelfPri" ></RadzenNumeric>SelfPri
            </div>

        </div>
        <div class="mat-layout-grid-inner">

            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="InpPrimeMin" @bind-Value="@inpamin" ></RadzenNumeric>InpPrimeMin
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="InpPrimeMax" @bind-Value="@inpamax" ></RadzenNumeric>InpPrimeMax
            </div>
        </div>
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="ThreshPri" @bind-Value="@ThreshPri" ></RadzenNumeric>ThreshPri
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="inhPri" @bind-Value="@inhPri" ></RadzenNumeric>inhPri
            </div>
        </div>
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="biasPri" @bind-Value="@biasPL" ></RadzenNumeric>biasPri
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="conPri" @bind-Value="@conPrime" ></RadzenNumeric>conPri
            </div>
        </div>
    </div>
    
    <p>Target</p>
    <div class="mat-layout-grid">
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="CrossTar" @bind-Value="@CrossTar" ></RadzenNumeric>CrossTar
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="SelfTar" @bind-Value="@SelfTar" ></RadzenNumeric>SelfTar
            </div>

        </div>
        <div class="mat-layout-grid-inner">

            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="InpTargetMin" @bind-Value="@inpbmin" ></RadzenNumeric>InpTargetMin
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="InpTargetMax" @bind-Value="@inpbmax" ></RadzenNumeric>InpTargetMax
            </div>
        </div>
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="inhTar" @bind-Value="@inhTar" ></RadzenNumeric>inhTar
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="ThreshTar" @bind-Value="@ThreshTar" ></RadzenNumeric>ThreshTar
            </div>

        </div>
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="biasTar" @bind-Value="@biasPR" ></RadzenNumeric>biasTar
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="conTar" @bind-Value="@conTarget" ></RadzenNumeric>conTar
            </div>

        </div>
    </div>

    <p>Response</p>
    <div class="mat-layout-grid">
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="SelfO" @bind-Value="@SelfO" ></RadzenNumeric>SelfO
            </div>

            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="inhO" @bind-Value="@inhO" ></RadzenNumeric>inhO
            </div>
        </div>
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="ThreshO" @bind-Value="@ThreshO" ></RadzenNumeric>ThreshO
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="biasOut" @bind-Value="@biasOut" ></RadzenNumeric>biasOut
            </div>
        </div>
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="conResponse" @bind-Value="@conResponse" ></RadzenNumeric>conResponse
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="conResponse" @bind-Value="@conResponse" ></RadzenNumeric>conResponse
            </div>
        </div>
    </div>

    <p>Task</p>
    <div class="mat-layout-grid">
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="SelfT" @bind-Value="@SelfT" ></RadzenNumeric>SelfT
            </div>

            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="inhT" @bind-Value="@inhT" ></RadzenNumeric>inhT
            </div>
        </div>
        <div class="mat-layout-grid-inner">

            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="ThreshT" @bind-Value="@ThreshT" ></RadzenNumeric>ThreshT
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="inhT" @bind-Value="@biasTask" ></RadzenNumeric>inhT
            </div>
        </div>
    </div>

    <p>Conflict</p>
    <div class="mat-layout-grid">
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="ThresholdConf" @bind-Value="@ThreshConf" ></RadzenNumeric>ThresholdConf
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="CLC" @bind-Value="@cLC" ></RadzenNumeric>cLC
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="CLCthresh" @bind-Value="@CLCthresh" ></RadzenNumeric>cLCThresh
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="CLC" @bind-Value="@g1" ></RadzenNumeric>gPrime
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="CLCthresh" @bind-Value="@g2" ></RadzenNumeric>gTarget
            </div>
        </div>
    </div>

    <p>Mask</p>
    <div class="mat-layout-grid">
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="SelfMasks" @bind-Value="@SelfMasks" ></RadzenNumeric>SelfMasks
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="BiasMasks" @bind-Value="@BiasMasks" ></RadzenNumeric>BiasMasks
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="CrossLMasks" @bind-Value="@CrossLMasks" ></RadzenNumeric>CrossLMasks
            </div>
        </div>
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="ConMasks" @bind-Value="@ConMasks" ></RadzenNumeric>ConMasks
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="InhMasks" @bind-Value="@InhMasks" ></RadzenNumeric>InhMasks
            </div>
        </div>
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="M_T_ISI_Coef" @bind-Value="@durM_T_ISIcoef" ></RadzenNumeric>M_T_ISI_Coef
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="InpPrimeMask" @bind-Value="@inpamask" ></RadzenNumeric>InpPrimeMask
            </div>
            <div class="mat-layout-grid-cell">
                <RadzenNumeric Placeholder="InpTargetMask" @bind-Value="@inpbmask" ></RadzenNumeric>InpTargetMask
            </div>
        </div>
    </div>

        </RadzenCard>
        </RadzenTabsItem>
        </Tabs>
    </RadzenTabs>
    </div>
</div>




@code
{
    [Parameter]
    public int idx1 {get; set;}=0;

    void  MyMethodAsyncX()
    {
        navigationManager.NavigateTo("/");
    }
    
            void asoPageA()
    {

               if (1==1)//asoHabit=="Priming")
        {
            MyMethodAsync();
        }
        }
 

    
        void asoPageC(string page)
    {
        state.SelectedCategoryId = int.Parse(page);
                  //  MyMethodAsync();

       //state.NextCategory();
        idx1=int.Parse(page);
        asoHabit=asoHabitList[idx1-1];
      //  if (asoHabit=="Priming")
       // {
        //    MyMethodAsync();
       // }

        
        StateHasChanged();    
    }


      void OnClick(string buttonName)
    {
        if (buttonName=="Home")
        {
         navigationManager.NavigateTo("/");
        }
        else
        {
         navigationManager.NavigateTo("/cm");
        }
       // console.Log($"{buttonName} clicked");

    }

    public long asoIndex=0;
    public string[] asoHabitList=new string[5];
        public string asoHabit="";



   
   protected override void OnInitialized()
    {

      for (int i=0;i<dataService.CategoryList.Count;i++)//dataService.HabitList.Count-1;i++)
       {
          asoHabitList[i]= dataService.CategoryList[i].Description;
       }

        asoHabit=asoHabitList[0];

                    dataService.PropertyChanged += PropertyChanged;
            state.PropertyChanged += PropertyChanged;
           StateHasChanged(); 
     }

             void PropertyChanged(object? sender, EventArgs e)
        {
            StateHasChanged();
        }
            protected override void OnParametersSet()
     {
                  asoIndex=state.SelectedCategoryId;
                  StateHasChanged();
     }


    void asoIndx()
    {
         asoHabit=asoHabitList[1];
                  asoIndex=state.SelectedCategoryId;
                  StateHasChanged();
    }

        private string _selectedNodeId = "";
        private string[] _selectedNodeIds = new string[0];

        public string asoNode = "0";
        public string asoNodes="00";

   
    void OnChange(object value, string name)
    {
       // var str = value is IEnumerable<object> ? string.Join(", ", (IEnumerable<object>)value) : value;

        //console.Log($"{name} value changed to {str}");
                    StateHasChanged();

    }


    void OnChange(int index)
    {
       // console.Log($"Tab with index {index} was selected.");
                   StateHasChanged();

    }

   // EventConsole console;
    void Change(object value, string name, string action)
    {
       // console.Log($"{name} item with index {value} {action}");
                   StateHasChanged();

    }

//fieldset Radzen Datalist     
public int asoPageSize {get; set;}=5;




    bool createUserDialogOpen = false;

    async Task asoKeepDataSingleTrial()
    {
        // singleTrialArray = singleTrialList.ToArray();
        asoSingleTrialSpeed = N;
        await InvokeAsync(StateHasChanged);
    }

    // IEnumerable<int> values = new int[] { 14, 78 };



    void Change(dynamic value, string name)
    {
        //var str = value is IEnumerable ? string.Join(", ", value) : value;
        // events.Add(DateTime.Now, $"{name} value changed to {str}");
        StateHasChanged();
    }


    public int asoSingleTrialSpeed = 150;
    //int valueWithStep = 30;
    bool smoothModels = true;
    bool smoothTrials = true;
    bool smoothTrial = true;

   public bool singleTrialChartPrime { get; set; } = true;
   public bool singleTrialChartTarget { get; set; } = true;
   public bool singleTrialChartResponse { get; set; } = true;
   public bool singleTrialChartTask { get; set; } = true;
   public bool singleTrialChartAttention { get; set; } = true;
   public bool singleTrialChartConflict { get; set; } = true;

    bool modelsChart = true;
    bool trialsChart = true;
    bool primeChart = false;
    bool targetChart = false;
    bool responseChart = false;
    bool taskChart = false;
    bool attentionChart = false;
    bool conflictChart = false;


    trialDataItem[] trialsRTarray = new trialDataItem[] { };
    modelDataItem[] modelsRTarray = new modelDataItem[] { };
    singleTrialDataItem[] singleTrialArray = new singleTrialDataItem[] { };

    public class singleTrialDataItem
    {
        //public DateTime Date { get; set; }
        public string singleTrialCycle { get; set; }
        public double singleTrialOutbLLX { get; set; }
        public double singleTrialOutbLRX { get; set; }
        public double singleTrialOutbLMX { get; set; }
        public double singleTrialOutbRLX { get; set; }
        public double singleTrialOutbRRX { get; set; }
        public double singleTrialOutbRMX { get; set; }
        public double singleTrialOutaLX { get; set; }
        public double singleTrialOutaRX { get; set; }
        public double singleTrialOutaThresh { get; set; }
        public double singleTrialTaskLX { get; set; }
        public double singleTrialTaskRX { get; set; }
        public double singleTrialTaskThresh { get; set; }
        public double singleTrialAttV { get; set; }
        public double singleTrialAttU { get; set; }
        public double singleTrialAttHv { get; set; }
        public double singleTrialConf { get; set; }
        public double singleTrialConfThresh { get; set; }
        public double singleTrialConfTrial { get; set; }

    }


    public class trialDataItem
    {
        //public DateTime Date { get; set; }
        public double trialRT { get; set; }
        public string trialCycleX { get; set; }

    }



    public class modelDataItem
    {
        public string modelCycleX { get; set; }
        public double modelRTc { get; set; }
        public double modelRTi { get; set; }
        public double modelRTic { get; set; }

        public string TrialsStr { get; set; }

    }

    // List<DataItem> ModelsData2 = new List<DataItem>();

    List<trialDataItem> trialsRTlist = new List<trialDataItem>();
    List<modelDataItem> modelsRTlist = new List<modelDataItem>();
    List<singleTrialDataItem> singleTrialList = new List<singleTrialDataItem>();
    List<singleTrialDataItem> singleTrialListack = new List<singleTrialDataItem>();

    string FormatAsUSD(object value)
    {
        return ((double)value).ToString("F1", CultureInfo.InvariantCulture);
    }

    public int tabIndex = 0;

    void ChangeTab(MouseEventArgs e)
    {
        if (spinning == false)
        {
            tabIndex = tabIndex == 0 ? 3 : 0;//(tabIndex < 3 & tabIndex >1) ? tabIndex - 1 : 3;

        }
    }

    //IEnumerable<modelDataItem> modelsRTlist;


    void Change(string text)
    {
        // orders = modelsRTlist.ToList();//dbContext.Orders.Include("Customer").Include("Employee").ToList();

        //console.Log($"{text}");
    }
    public string AsoStr = "Cognitive";

    int currentCount = 0;

    bool spinning = false;
    //definition1 start

    /// <summary>
    /// //////////////////////////////////////////num loop and dur////////////////>>>>>>>

    int ModelNumber = 5;

    string TrialsStr1 = "";

    int TrialNumber = 10;

    int N = 1000;

    public double mProgress { get; set; }
    public double nProgress { get; set; }


    public int m, n, c;// nTotal;
    int i, j;

    int durFix = 500;
    int durPrime = 45;
    int durMask = 75;
    int durTarget = 200;

    int durM_T_ISIcoef = 35;

    public int durMaskTargetISI = 0;

    public int durPrimeMaskISI = 0;

    //aso////////////////////////////////////////////////rt////////////////

    int onceTime1;/// <summary>////////Rt once!
    int rt;
    int rtI;
    int rtC;
    int rtMeanI;
    int rtMeanC;
    int rtSumC;
    int rtSumI;

    // int rtMeanI0;
    int rtMeanC0;
    //int rtMeanI1;
    int rtMeanC1;
    //int rtMeanI2;
    int rtMeanC2;
    //int rtMeanI3;
    int rtMeanC3;
    //int rtMeanI4;
    int rtMeanC4;

    int onceCycle;
    int ic;

    /// <summary>
    /// ///////////////////////Conf Hop Att
    /// </summary>
    ///
    double cLC = 3.85;
    double CLCthresh = 1.00;
    double ThreshConf = 1;
    double ConfTrial = 0;

    int CueOnset = 0;
    int CueOffset = 0;

    int ACH = 0;
    int ThreshACH = 0;

            double landaP = 0.95;//double.Parse(TextLandaP.Text); //0.95
                                 // alfaP.
            double alfaP = 1; //0.8

            double landaM = 0.74; //double.Parse(TextLandaM.Text); //0.74
            double landaR = 0.925;// double.Parse(TextLandaR.Text); //0.925
                                  // alfaR.
            double alfaR = 1.0D; //0.2
            double landaT = .75;//double.Parse(TextLandaT.Text);//.75

            ///''''''cowan
            // v.
            double v = .3;// double.Parse(TextV0.Text);//.3
                          // u.
            double u = 0;
            // vACH.
            double vACH = 0;
            // uACH.
            double uACH = 0;
            // hv.
            double hv = 0;
            // hvACH.
            double hvACH = 0;
            // thv.
            double thv = .98;// double.Parse(TextThv.Text); //0.98

            //hv = thv * hv + (1# - thv) * v

            // tv.
            double tv = .92;// double.Parse(TextTv.Text); //0.92
                            // tu.
            double tu = .996;// double.Parse(TextTu.Text); //0.996

            // a1.
            double a1 = 2;
            // a2.
            double a2 = 3;

            // t1.
            double t1 = 1.25;
            // t2.
            double t2 = 1.5;

            // b.
            double b = 4;
            //n = (short) 1;
            // For n = 1 To CShort(Text1TrialsNumber.Text)

            // neLCT.
            double neLCT = 0;
            // neLCP.
            double neLCP = 0;
            double neLC = 0;
            double Conf = 0;

            // g1.
            double g1 = 3;// double.Parse(TextGain1.Text);//3
                          // g2.
            double g2 = 1;// double.Parse(TextGain2.Text);//1

            // cLC.
            //double cLC = CLC;// double.Parse(TextcLCL.Text);//4.52

            ///TextGain2.Text = 3

            // g1.
            // g.
            double g;
            //g = 3;
            int iHop;

            //future

            //ic = 1;
            double neLCACHp, neLCACHt, neLCACH;

    double[,] ar5 = new double[3, 3];
    double[] inp = new double[3];
    double[] upd = new double[3];

    double[] gainRate1 = new double[3];
    double[] gainRate2 = new double[3];
    double[] gainRate = new double[3];

    double[] inpConf = new double[4];
    double[] updConf = new double[4];

    double energyHop;

    //aso var ////////////////////////////////Layers act

    double[] taskX = new double[3];
    double[] taskY = new double[3];
    double[] outaX = new double[4];
    double[] outbLX = new double[4];
    double[] outbRX = new double[4];
    double[] inpaX = new double[4];
    double[] inpbX = new double[4];
    double[] outaY = new double[4];
    double[] outbLY = new double[4];
    double[] outbRY = new double[4];

    ///////////////////////////////////////////////////////con
    //conLO
    double conResponse = 1.5;
    //conRO
    // double[] conROArray = { 1.5, 1.5 };

    //conLT
    double conPrime = 3.0;
    //conRT
    double conTarget = 3.0;

    //cona
    double conPrimeTask = 1;

    //conb
    double conTargetTask = 1;

    // double ConMasks = 1.50;
    double ConMasks = 1.50;
    ///////////////////////////////////////////////////////self

    double SelfMasks = 1.50;
    // double SelfMasks = 1.50;
    double SelfPri = 1.50;
    double SelfTar = 1.50;
    double SelfO = 1.00;
    double SelfT = 1.00;

    ///////////////////////////////////////////////////////cross

    double CrossPri = 0.33;
    double CrossTar = 0.33;

    double CrossLMasks = 0.75;
    // double CrossLMasks = 0.75;

    ///////////////////////////////////////////////////////thresh

    double ThreshT = 0.45;
    double ThreshPri = 0.65;
    double ThreshTar = 0.65;
    double ThreshO = 0.7;

    ///////////////////////////////////////////////////////inh

    double inhO = -1.0;
    double inhPri = -1.0;
    double inhTar = -1.0;
    double InhMasks = -1.0;
    // double InhMasks = -1.0;
    double inhT = -1.0;

    ///////////////////////////////////////////////////////bias

    //int[] biasOutArray = { -2, -2 };

    //double[] biasPLArray = { -.5, -.5 };

    // double[] biasPRArray = { -.5, -.5 };

    // double[] biasTaskArray = { -.85, -.85 };

    double biasOut = -2.0;

    double biasPL = -0.5;

    double biasPR = -0.5;

    double biasTask = -1.25;

    double BiasMasks = -1.25; //other biases?!
                              // double BiasMasks = -0.5;

    /// <summary>
    /// ///////////////////////////////////////////////////noise
    /// </summary>
    double noisePTR = 0.15;// double.Parse(TextNoiseP.Text); //.5 ''noiseSD = 0.03 i.e. +- .05
                           // noiseLMI.
    double noiseMasks = 0.25;// double.Parse(TextNoiseLMI.Text);
                             // noiseT.
    double noiseTask = 0.05;// double.Parse(TextNoiseT.Text); //'noiseSD = 0.05 i.e. +- .070

    /// <summary>
    /// ////////////////////////////////////////////////////////inp
    /// </summary>
    double[] inpaArray = { 1, 0, 1 };

    double[] inpbArray = { 1, 0, 1 };

    //int[] inpaArray = { 1, 0, 1 };

    //int[] inpbArray = { 1, 0, 1 };

    double inpamin = 0;
    double inpamax = 1;

    double inpbmin = 0;
    double inpbmax = 1;

    double inpamask = 1;
    double inpbmask = 1;


    private bool Val0 = false;
    private bool Val1 = false;
    private bool Val2 = false;
    private bool Val3 = false;
    private bool Val4 = false;
    private bool Val5 = false;
    private bool Val6 = false;
    private bool Val7 = false;
    private bool Val8 = false;

    //int result = -1;

    //  public int Count { get; set; }

    //////////await start

    Stopwatch stopwatch = new Stopwatch();
    // public long asoTimeElapsed = 0;

    //  public int asoCountDown = 1;

    // List<Point> allTestData = new List<Point>();

    List<Models> ModelsData = new List<Models>();

    //Point pointsInpModelsCTable = new Point();
    // Point pointsInpModelsITable = new Point();

    // public class Point
    // {
    //    public double X { get; set; }
    //    public double Y { get; set; }
    //    public double Z { get; set; }
    // }

    //////graph

    //  var deltas = new Point[N - 1];
    //  Point min = new Point();
    // Point max = new Point();

    public class Models
    {
        public int No { get; set; }//whole string for messagedto?
        public double RTcong { get; set; }
        public double RTincong { get; set; }
        public string TrialsStr { get; set; }//non string
                                             //all params! or imps
                                             //single trial data?!
    }

    
    public void MyMethodAsync0()
    {
        spinning = false;

        n = TrialNumber;

        m = ModelNumber;

        n = TrialNumber;

        InvokeAsync(StateHasChanged);

        //result = -1;

    }

    int asoCountDown = 0;

    public async Task MyMethodAsync()
    {
        //asoCountDown = 1;

        if (spinning == true)
        {
            MyMethodAsync0();
        }
        else
        {
            modelsRTlist.Clear();
            //result = -1;

            spinning = true;
            Task longRunningTask = LongRunningOperationAsync(ModelNumber, TrialNumber, N);
        }
        // Count = TrialNumber;

        //c = ModelNumber;
        ////spinning = false;

        // createUserDialogOpen = true;
        //// await Task.Delay(1);
        ////await InvokeAsync(StateHasChanged);
        //// spinning = true;

        //ModelsData.Clear();

        ////modelsRTlist.Clear();



        // await Task.Run(() => LongRunningOperationAsync());  //<--here!
        //currentCount++;

        //m = ModelNumber;
        //n = TrialNumber;
        //c = N;
        //                await InvokeAsync(StateHasChanged);

        //and now we call await on the task
        //// Timer timer2 = new Timer(new TimerCallback(_ =>
        //// {
        ////  if (asoCountDown <= 0) return;
        ////  asoCountDown--;
        //c
        // Note that the following line is necessary because otherwise
        // Blazor would not recognize the state change and not refresh the UI

        // Task longRunningTask = LongRunningOperationAsync(ModelNumber, TrialNumber, N);

        ////   InvokeAsync(StateHasChanged);
        //// }), null, 1000, 1000);

        // independent work which doesn't need the result of LongRunningOperationAsync can be done here
        // await longRunningTask;

        //Val0 = false;
        //use the result

        ////spinning = false;
        //// await Task.CompletedTask;
    }

///////    to bring up later
    public async Task LongRunningOperationAsync(int ModelCount, int TrialCount, int CycleCount) // assume we return an int from this long running operation
    {

        //double[,] ModelsICPloty = new double[ModelNumber, 2];

        //for (int i = 0; i < ModelCount; i++)
        // {
        //     pointsInpModelsCPloty[i] = new Point { X = i, Y = 0 };
        //    pointsInpModelsIPloty[i] = new Point { X = i, Y = 0 };
        //    pointsInpModelsI_CPloty[i] = new Point { X = i, Y = 0 };
        // }

        //////////////////////////////////////m===================1==========>.....


        for (m = 0; m < ModelCount; m++)
        {


            for (i = 0; i <= 2; i++)
            {

                // i.
                // outbLX(i).
                outbLX[i] = 0;
                outbLY[i] = 0;

                // i.
                // outbRX(i).
                outbRX[i] = 0;
                outbRY[i] = 0;

                // i.
                // taskX(i).
                taskX[i] = 0;
                taskY[i] = 0;

                // i.
                // outaX(i).
                outaX[i] = 0;
                outaY[i] = 0;

            }


            for (i = 0; i <= 1; i++)
            {
                // i.
                // gainRate(i).
                gainRate[i] = 1;
                // i.
                // gainRate1(i).
                gainRate1[i] = 1;
                // i.
                // gainRate2(i).
                gainRate2[i] = 1;

                // gainRate(2).
                gainRate[2] = 1;

            }


            if (1 == 2) /////////// for continue model or add initial noise
            {

                // i.
                // outbLX().
                // outbLX(i).
                outbLX[i] = outbLX[i];// + samplesP1[i];
                                      // i.
                                      // outbLY(i).
                outbLY[i] = 0;

                // i.
                // outbRX().
                // outbRX(i).
                outbRX[i] = outbRX[i];// + samplesP1[i];
                                      // i.
                                      // outbRY(i).
                outbRY[i] = 0;

                //taskX(i) = 0#
                //taskY(i) = 0#
                //outaX(i) = outaX(i) + GausDeviation(1 * Val(TextNoiseRI.Text)) 'outaX(i) * Val(TextNoiseRI.Text) '
                //outaY(i) = 0#

                // outbLX().
                // outbLX(2).
                outbLX[2] = outbLX[2];// + samplesP1[2];
                                      // outbLY(2).
                outbLY[2] = 0;

                // outbRX().
                // outbRX(2).
                outbRX[2] = outbRX[2];// + samplesP1[2];
                                      // outbRY(2).
                outbRY[2] = 0;

                ///'''''''''''''''''''''''''''''''''''''''''

            }

            // energyHop.

            for (i = 0; i <= 1; i++)
            {
                // i.
                // upd(i).
                upd[i] = 0;
                for (j = 0; j <= 1; j++)
                {
                    // j.
                    // i.
                    // j.
                    // i.
                    // ar5(i, j).
                    if (i != j)
                    {
                        ar5[i, j] = -1;// double.Parse(inhT.Text);
                    }
                    else
                    {
                        // j.
                        // i.
                        // ar5(i, j).
                        ar5[i, j] = 0;
                    }
                }
            }

            //asoarr

            //double[] inpaArray = { 1, 0, 1 };

            // double[] inpbArray = { 1, 0, 1 };

            // energyHop.
            energyHop = 0;
            onceTime1 = 0;

            rt = 0;
            rtI = 1;
            rtC = 1;
            rtMeanI = 0;
            rtMeanC = 0;

            rtSumC = 0;
            rtSumI = 0;

            inp[0] = 0;
            // inp(1).
            inp[1] = 0;

            Random random = new Random(DateTime.Now.Millisecond);

            //if (ModelNumber > 0)
            // {
            durMaskTargetISI = m * durM_T_ISIcoef;

            //durMask += m * 15;
            // }

            // if (!(chartTrial.Data.ElementAt(1) is Scatter scatterTrial1)) return;

            trialsRTlist.Clear();


            TrialsStr1 = "";

            //aso///////////////////////////////////>>>>n>>>>>>2>>>>>>>>>>>>>>>>>>>>>
            for (n = 0; n < TrialCount; n++)
            {

                ConfTrial = 0;
                onceTime1 = 0;

                Random randomIC = new Random(DateTime.Now.Millisecond);

                //if (Val1 == true)
                //{
                //    inpaArray[0] = 1;
                //    inpbArray[0] = 1;
                //    inpaArray[1] = 0;
                //    inpbArray[1] = 0;
                //    ic = 1;

                //}
                //else
                //{
                //    inpaArray[0] = 1;
                //    inpbArray[0] = 0;
                //    inpaArray[1] = 0;
                //    inpbArray[1] = 1;
                //    ic = 2;

                // }

                // if (TrialNumber > 1)
                // {

                int num = randomIC.Next();
                //MessageBox.Show((num % 2).ToString());
                if (num % 2 == 0)
                {
                    inpaArray[0] = inpamax;
                    inpbArray[0] = inpbmax;
                    inpaArray[1] = inpamin;
                    inpbArray[1] = inpbmin;
                    ic = 1;
                }
                else
                {
                    inpaArray[0] = inpamax;
                    inpbArray[0] = inpbmin;
                    inpaArray[1] = inpamin;
                    inpbArray[1] = inpbmax;
                    ic = 2;
                }

                //}

                inpaArray[2] = inpamask;
                inpbArray[2] = inpbmask;


                //do if (n > 1)//double.Parse(Text1TrialsNumber.Text) == 1)
                //do {
                //cyclePrime.Text = "1200";// ((short)short.Parse(cyclePrime.Text) - 500).ToString();
                //durFix.Text = "500";//((short)short.Parse(durFix.Text) - 500).ToString();
                //do }


                //await chartModel.Clear();
                //await InvokeAsync(StateHasChanged);
                // await Task.Delay(1); // 1 second delay

                singleTrialList.Clear();


                ////////////////////////////////////---c------3----------....>>>>>>>

                for (c = 0; c < CycleCount; c++)
                {
                    g = g1;
                    // await InvokeAsync(StateHasChanged);
                    // await Task.Delay(1); // 1 second delay


                    // await Task.Delay(1);
                    // c.
                    if (c > durFix && c <= durFix + durPrime)
                    {

                        for (i = 0; i <= 1; i++)
                        {
                            // i.
                            // inpaX(i).
                            inpaX[i] = inpaArray[i];

                        }

                    }
                    else
                    {

                        for (i = 0; i <= 1; i++)
                        {

                            inpaX[i] = 0;
                        }

                    }

                    ///////////////////////////////////////preMaskISI
                    ///


                    if (c > durFix + durPrime + durPrimeMaskISI && c <= durFix + durPrime + durPrimeMaskISI + durMask)
                    {
                        // inpaX(2).
                        inpaX[2] = inpaArray[2];
                        // inpbX(2).
                        inpbX[2] = inpbArray[2];

                    }

                    else
                    {
                        // inpaX(2).
                        inpaX[2] = 0;
                        // inpbX(2).
                        inpbX[2] = 0;

                    }

                    // preISI.
                    if (c > durFix + durPrime + durPrimeMaskISI + durMask + durMaskTargetISI && c <= durFix + durPrime + durPrimeMaskISI + durMask + durMaskTargetISI + durTarget)
                    {

                        for (i = 0; i <= 1; i++)
                        {
                            // i.
                            // inpbX(i).
                            inpbX[i] = inpbArray[i];

                        }

                    }

                    else
                    {
                        for (i = 0; i <= 1; i++)
                        {
                            inpbX[i] = 0;
                        }
                    }

                    ///'new
                    //For i = 0 To 1
                    //  If Val(TextThreshACH.Text) > 0 And (taskX(0) > Val(TextThreshACH.Text) Or taskX(1) > Val(TextThreshACH.Text)) Then gainRate1(i) = Val(Abs(TextRatioIC.Text))
                    //If c > Val(durFix) + Val(durPrime) Then gainRate1(i) = 1
                    //Next
                    ///'''''''''''''tmpVal(TextRatioTask.Text)
                    //newer

                    neLCACHp = 0;
                    if (ThreshACH > 0)
                    {
                        // neLCACHp.
                        neLCACHp = 0;
                        for (i = 0; i <= 1; i++)
                        {
                            //If (c > Val(durFix) And c <= Val(durFix) + Val(TextThreshACH.Text)) Then gainRate1(i) = Val(Abs(TextRatioIC.Text)) Else gainRate1(i) = 1
                            // c.
                            if (c > durFix && c <= durFix + ThreshACH)
                            {
                                // i.
                                // vACH.
                                // gainRate1(i).
                                gainRate1[i] = Math.Abs(ACH) * vACH;
                                // neLCACHp.
                                neLCACHp = 1;
                            }
                            else
                            {
                                // i.
                                // gainRate1(i).
                                gainRate1[i] = 1;
                                // neLCACHp.
                                neLCACHp = 0;
                            }
                            // i.
                            // gainRate1(i).
                            // i.
                            // gainRate1(i).
                            if (gainRate1[i] < 1)
                            {
                                gainRate1[i] = 1;
                            }
                        }
                    }

                    ///''''''''''''''''''''''''''''''''''''''''''''''''newest

                    ///'''''''''''''tmpVal(TextRatioTask.Text)      preISI + Val(durFix.Text) + Val(durPrime.Text) + Val(durMask.Text) + Val(durTarget.Text)
                    //newer

                    neLCACHt = 0;
                    if (ACH > 0)
                    {
                        // neLCACHt.
                        neLCACHt = 0;

                        for (i = 0; i <= 1; i++)
                        {
                            // preISI.
                            if (c > durFix + durPrime + durMask + durMaskTargetISI && c <= durFix + durPrime + durMask + durMaskTargetISI + ACH)
                            {
                                // i.
                                // vACH.
                                // gainRate2(i).
                                gainRate2[i] = Math.Abs(ACH) * vACH;
                                // neLCACHt.
                                neLCACHt = 1;
                            }
                            else
                            {
                                // i.
                                // gainRate2(i).
                                gainRate2[i] = 1;
                                // neLCACHt.
                                neLCACHt = 0;
                            }
                            // i.
                            // gainRate2(i).
                            // i.
                            // gainRate2(i).
                            if (gainRate2[i] < 1)
                            {
                                gainRate2[i] = 1;
                            }
                        }
                    }

                    ///'''''''''''''''''''''''''''''''''''''''*.6  *.4
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''
                    ///'''''''''''''''''''''''''''''''''''''''

                    // noiseLMI.
                    // outbLX(1).
                    // outbLX(0).
                    // inpaX(1).
                    // inpaX(0).
                    // inpaX(2).
                    // outbLX(2).
                    // outbLY(2).

                    // Random rnd1 = new Random();
                    double samplesLMI1 = Draw(noiseMasks);//(rnd1.NextDouble() - .5) / 10;

                    //public static double ff25(double xme, double μ = 0.0, double σ = 0.25)
                    // {
                    //   return 1d / Math.Sqrt(2 * 0.25 * 0.25 * Math.PI) * Math.Exp(-((xme - 0.0) * (xme - 0.0) / (2 * 0.25 * 0.25));
                    // }

                    outbLY[2] = BiasMasks + outbLX[2] * SelfMasks + inpaX[2] * ConMasks + inpaX[0] * CrossPri + inpaX[1] * CrossPri + outbLX[0] * InhMasks + outbLX[1] * InhMasks + samplesLMI1; //- outbLY(i) '2L gets in from 1 only (abs..)

                    // noiseRMI.
                    // outbRX(1).
                    // outbRX(0).
                    // inpbX(1).
                    // inpbX(0).
                    // inpbX(2).
                    // outbRX(2).
                    // outbRY(2).\

                    // double samplesRMI1 = Draw25();//(rnd1.NextDouble() - .5) / 10;

                    double samplesRMI1 = Draw(noiseMasks);//(rnd1.NextDouble() - .5) / 10;


                    outbRY[2] = BiasMasks + outbRX[2] * SelfMasks + inpbX[2] * ConMasks + inpbX[0] * CrossTar + inpbX[1] * CrossTar + outbRX[0] * InhMasks + outbRX[1] * InhMasks + samplesRMI1; //- outbLY(i) '2L gets in from 1 only (abs..)

                    for (i = 0; i <= 1; i++)
                    {
                        // net         self         inp1            con1                       inh/compete
                        // i.
                        // noiseP.
                        // outbLX(2).
                        // outbLX( + 2).
                        // inpaX(i).
                        // inpaX( + 2).
                        // outbLX(i).
                        // outbLY(i).

                        //double samplesP1 = Draw2();//(rnd1.NextDouble() - .5) / 10;

                        double samplesP1 = Draw(noisePTR);//(rnd1.NextDouble() - .5) / 10;


                        outbLY[i] = biasPL + outbLX[i] * SelfPri + inpaX[((short)(~i)) + 2] * CrossPri + outbLX[2] * CrossLMasks + inpaX[i] * conPrime + outbLX[((short)(~i)) + 2] * inhPri + outbLX[2] * InhMasks + samplesP1; //- outbLY(i) '2L gets in from 1 only (abs..)
                                                                                                                                                                                                                                // outbRX(i).
                                                                                                                                                                                                                                // outbRY(i).
                        outbRY[i] = biasPR + outbRX[i] * SelfTar + inpbX[((short)(~i)) + 2] * CrossTar + outbRX[2] * CrossLMasks + inpbX[i] * conTarget + outbRX[((short)(~i)) + 2] * inhTar + outbRX[2] * InhMasks + samplesP1; // - outbRY(i)  '2R gets in from 1 only (abs..)
                                                                                                                                                                                                                                 //aso rp?  }
                    }

                    for (i = 0; i <= 1; i++)
                    {
                        // i.
                        // gainRate1(i).
                        // gainRate(i).
                        // alfaP.
                        // outbLY().
                        // landaP.
                        // outbLX().
                        // outbLX(i).
                        outbLX[i] = landaP * outbLX[i] + (1.0D - landaP) * (1.0D / (1.0D + Math.Exp(-outbLY[i] * alfaP * gainRate[i] * gainRate1[i])));
                        // i.
                        // gainRate2(i).
                        // gainRate(i).
                        // alfaP.
                        // outbRY().
                        // landaP.
                        // outbRX().
                        // outbRX(i).
                        outbRX[i] = landaP * outbRX[i] + (1.0D - landaP) * (1.0D / (1.0D + Math.Exp(-outbRY[i] * alfaP * gainRate[i] * gainRate2[i])));

                        // c.
                        // i.
                        // outbLX(i).
                        // leftRightPL().
                        // leftRightPL(i, c - 1).
                        // leftRightPL[i, c - 1] = leftRightPL[i, c - 1] + outbLX[i];
                        // c.
                        // i.
                        // outbRX(i).
                        // leftRightPR().
                        // leftRightPR(i, c - 1).
                        //leftRightPR[i, c - 1] = leftRightPR[i, c - 1] + outbRX[i];
                    }

                    // gainRate(2).
                    // outbLY().
                    // landaM.
                    // outbLX().
                    // outbLX(2).
                    outbLX[2] = landaM * outbLX[2] + (1.0D - landaM) * (1.0D / (1.0D + Math.Exp(-outbLY[2] * gainRate[2])));

                    // gainRate(2).
                    // outbRY().
                    // landaM.
                    // outbRX().
                    // outbRX(2).
                    outbRX[2] = landaM * outbRX[2] + (1.0D - landaM) * (1.0D / (1.0D + Math.Exp(-outbRY[2] * gainRate[2])));

                    for (i = 0; i <= 1; i++)
                    {
                        // i.

                        // noiseT.
                        // taskX( + 2).
                        // outbRX(i).
                        // outbLX(i).
                        // taskX(i).
                        // taskY(i).

                        // double samplesT1 = Draw025();//(rnd1.NextDouble() - .5) / 10;

                        double samplesT1 = Draw(noiseTask);//(rnd1.NextDouble() - .5) / 10;

                        taskY[i] = biasTask + taskX[i] * SelfT + outbLX[i] * conPrimeTask + outbRX[i] * conTargetTask + taskX[((short)(~i)) + 2] * inhT + samplesT1; //- taskY(i)
                    }

                    ///'''''''

                    for (i = 0; i <= 1; i++)
                    {
                        // net         self         inp1            con1                       inh/compete
                        // leftRightPL(i, c - 1) = leftRightPL(i, c - 1) + outbLX(i)
                        // leftRightPR(i, c - 1) = leftRightPR(i, c - 1) + outbRX(i)

                        // taskX(i) = landaT * taskX(i) + (1 - landaT) * (1# / (1# + Math.Exp(-taskY(i)))) '* gainRate(i))))
                        // i.
                        // gainRate(i).
                        // taskY().
                        // landaT.
                        // taskX().
                        // taskX(i).
                        taskX[i] = landaT * taskX[i] + (1 - landaT) * (1.0D / (1.0D + Math.Exp(-taskY[i] * gainRate[i])));

                        /// biasTask(i).Text = -1
                        //task(i).Text = Format(taskX(i), "#.00")
                    }

                    ///'''''''''NEW HOP
                    ///'''''''''NEW HOP

                    if (ThreshT > 0)  ///if using Task
                    {

                        for (i = 0; i <= 1; i++)
                        {
                            inpConf[i] = 0;

                            // i.
                            // taskX(i).
                            // i.
                            // inp(i).
                            if (taskX[i] > ThreshT)
                            {
                                inpConf[i] = 1;
                            }
                            // else
                            // {
                            // i.
                            // inp(i).
                            //  inp[i] = 0;
                            // } //-1
                        }

                    }
                    else //not using Task but L or R representation layer
                    {

                        for (i = 0; i <= 1; i++)
                        {
                            inpConf[i] = 0;

                            // i.
                            // inp(i).
                            // outbLX(i).
                            // i.
                            // inp(i).
                            if (outbLX[i] > ThreshPri || outbRX[i] > ThreshTar)
                            {
                                inpConf[i] = 1;
                            }
                            //Else inp(i) = 0 '-1
                        }

                        //for (i = 0; i <= 1; i++)
                        // {
                        //   inp[i] = 0;

                        // i.
                        // inp(i).
                        // outbRX(i).
                        // i.
                        // inp(i).
                        // if (outbRX[i] > ThreshTar && inp[i] != 1)
                        // {
                        //    inp[i] = 1;
                        // }
                        //Else inp(i) = 0  '-1
                        ///End If

                        //inp(i) = taskX(i) - 0.5
                        // i.
                        // upd(i).
                        //upd[i] = 0;
                        //}

                    }

                    ///   temp = 0;
                    // energyHop.
                    energyHop = 0;

                    for (iHop = 1; iHop <= 1; iHop++)//////not implementett
                    {

                        for (i = 0; i <= 1; i++)
                        {
                            updConf[i] = 0;//////not implementett
                            for (j = 0; j <= 1; j++)
                            {
                                // i.
                                // upd(i).
                                // j.
                                // inp(j).
                                // ar5().
                                updConf[i] = ar5[i, j] * inpConf[j] + updConf[i];//////not implementett
                                                                                 // i.
                                                                                 // inp(i).
                                                                                 // j.
                                                                                 // inp(j).
                                                                                 // ar5().
                                                                                 // energyHop.
                                energyHop = energyHop - ar5[i, j] * inpConf[j] * inpConf[i];
                            }

                            //temp = temp + energyHop
                        }

                        //tempAll = tempAll + temp

                        //For i = 0 To 1
                        //  If upd(i) >= 0 Then inp(i) = 1
                        // If upd(i) < 0 Then inp(i) = -1
                        //Next i

                    }

                    ///''''''''''''''END
                    // energyHop.
                    // Conf.
                    Conf = energyHop / 2; // '(taskX(0) - 0.5) * (taskX(1) - 0.5) / (Abs(taskX(0) - 0.5) * Abs(taskX(1) - 0.5))

                    //2018-9  exe att
                    // neLC.
                    neLC = 0;

                    // outbLX(1).
                    // outbLX(0).
                    // neLCP.
                    if (outbLX[0] >= ThreshPri || outbLX[1] >= ThreshPri)
                    {
                        neLCP = 1;
                    }
                    else
                    {
                        // neLCP.
                        neLCP = 0;
                    }

                    // n.
                    // c.
                    // neLCC.
                    //2018-9   cue/orient? att

                    if (outbRX[0] >= ThreshTar || outbRX[1] >= ThreshTar)
                    {
                        neLCT = 1;
                    }
                    else
                    {
                        // neLCT.
                        neLCT = 0;
                    }

                    ConfTrial += Conf;

                    //if (ic == 2 & c > durFix + durPrime)//ConfTrial > ThreshConf && c > durFix)
                    // {
                    //g = g2;
                    //}

                    // g2.
                    // g.
                    // c.
                    // g1.
                    // g2.
                    // g.
                    if (ConfTrial < ThreshConf) //(c > durFix + durPrime && ic == 2)
                    {
                        g = g1;
                    }
                    else
                    {
                        g = g2;
                    }

                    // neLCACHt.
                    // neLCACHp.
                    // neLCACH.

                    //ach if (neLCACHp == 1 || neLCACHt == 1)
                    //ach {
                    //ach neLCACH = 1;
                    //ach  }
                    //ach else
                    //ach {
                    // neLCACH.
                    //ach neLCACH = 0;
                    //ach }

                    // uACH.
                    //ach if (ACH > 0 || ThreshACH > 0)
                    //ach {
                    //ach uACH = 0;
                    //ach }

                    // t1.
                    // neLCACH.
                    // uACH.
                    // b.
                    // vACH.
                    // a1.
                    // tv.

                    //ach vACH = tv * vACH + (1.0D - tv) * (1.0D / (1.0D + Math.Exp(-(3 * (a1 * vACH - b * uACH + neLCACH - t1)))));

                    // t2.
                    // vACH.
                    // a2.
                    // tu.
                    // uACH.

                    //ach uACH = tu * uACH + (1.0D - tu) * (1.0D / (1.0D + Math.Exp(-3 * (a2 * vACH - t2))));
                    // vACH.
                    // thv.
                    // hvACH.

                    //ach hvACH = thv * hvACH + (1.0D - thv) * vACH;

                    ///'''''''''
                    // neLCC.
                    // neLCT.
                    // neLCP.
                    // neLC.

                    if (neLCP == 1 || neLCT == 1) //| neLCC == 1
                    {
                        neLC = 1;
                    }
                    else
                    {
                        // neLC.
                        neLC = 0;
                    }

                    // t1.
                    // neLC.
                    // u.
                    // b.
                    // v.
                    // a1.
                    // g.
                    // tv.
                    v = tv * v + (1.0D - tv) * (1.0D / (1.0D + Math.Exp(-(g * (a1 * v - b * u + neLC - t1)))));
                    // t2.
                    // v.
                    // a2.
                    // g.
                    // tu.
                    // u.
                    u = tu * u + (1.0D - tu) * (1.0D / (1.0D + Math.Exp(-g * (a2 * v - t2))));
                    // v.
                    // thv.
                    // hv.
                    hv = thv * hv + (1.0D - thv) * v;

                    //If neLC = 1 And cLC * hv > 1 Then '(neLC = 1 Or onceTimeLC = True)

                    // hv.
                    // cLC.

                    if (cLC * hv > CLCthresh) //(neLC = 1 Or onceTimeLC = True)
                    {
                        for (i = 0; i <= 2; i++)
                        {
                            // i.
                            // hv.
                            // cLC.
                            // gainRate(i).
                            gainRate[i] = cLC * hv;
                        }

                    }

                    ///''''''''''''''''''upper left module
                    //outb con inh

                    for (i = 0; i <= 1; i++)
                    {
                        //net         bias                  self       inpFromPerc1     con1                         inpFromPerc2                           comp/inh
                        // i.
                        // noiseR.
                        // outaX( + 2).
                        // outbRX(i).
                        // outbLX(i).
                        // outaX(i).
                        // outaY(i).

                        //double samplesR1 = Draw2();//(rnd1.NextDouble() - .5) / 10;
                        double samplesR1 = Draw(noisePTR);//(rnd1.NextDouble() - .5) / 10;

                        outaY[i] = biasOut + outaX[i] * SelfO + outbLX[i] * conResponse + outbRX[i] * conResponse + outaX[((short)(~i)) + 2] * inhO + samplesR1; //- outaY(i)
                    }

                    for (i = 0; i <= 1; i++)
                    {
                        // i.
                        // gainRate(i).
                        // alfaR.
                        // outaY().
                        // landaR.
                        // outaX().
                        // outaX(i).
                        outaX[i] = landaR * outaX[i] + (1.0D - landaR) * (1.0D / (1.0D + Math.Exp(-outaY[i] * alfaR * gainRate[i])));

                    }

                    if ((outaX[0] >= ThreshO || outaX[1] >= ThreshO) && onceTime1 == 0) //And outaX(1) > outaX(0))
                    {
                        onceTime1 = 1;
                        //TextBoxMultiLine.AppendText(n.ToString() + "-L-L-" + c.ToString() + "---");
                        //rtMeanIC1 = c;
                        rt = c;


                        //TextBoxMultiLine.AppendText("rt new=" + (rt.ToString()));// double.Parse(Text1TrialsNumber.Text)).ToString() + "...");

                        // c=short.Parse(cyclePrime.Text);
                        //MessageBox.Show(outaX[0].ToString()+"--"+ outaX[1].ToString() + "--" + onceTime1.ToString());
                    }

                    //use _conLT_1 and _conLT_0 in task
                    //chart if (checkBox1ShowChart.Checked == true)

                    // pointsInpAtt[c] = new Point { X = v, Y = u, Z = hv };
                    // pointsInpPrime[c] = new Point { X = outbLX[0], Y = outbLX[1], Z = outbLX[2] };
                    //  pointsInpTarget[c] = new Point { X = outbRX[0], Y = outbRX[1], Z = outbRX[2] };
                    //  pointsInpConf[c] = new Point { X = c, Y = ConfTrial };
                    //  pointsInpTask[c] = new Point { X = taskX[0], Y = taskX[1], Z = taskX[2] };
                    //   pointsInpResponse[c] = new Point { X = outaX[0], Y = outaX[1], Z = outaX[2] };


                    ///////////////////////////////////////////////////.........>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                    if (c % asoSingleTrialSpeed == 0)
                    {


                        singleTrialList.Add(new singleTrialDataItem
                        {
                            singleTrialCycle = (c + 1).ToString(),
                            singleTrialOutbLLX = outbLX[0],
                            singleTrialOutbLRX = outbLX[1],
                            singleTrialOutbLMX = outbLX[2],
                            singleTrialOutbRLX = outbRX[0],
                            singleTrialOutbRRX = outbRX[1],
                            singleTrialOutbRMX = outbRX[2],
                            singleTrialOutaLX = outaX[0],
                            singleTrialOutaRX = outaX[1],
                            singleTrialOutaThresh = ThreshO,
                            singleTrialTaskLX = taskX[0],
                            singleTrialTaskRX = taskX[1],
                            singleTrialTaskThresh = ThreshT,
                            singleTrialAttV = v,
                            singleTrialAttU = u,
                            singleTrialAttHv = hv,
                            singleTrialConf = Conf,
                            singleTrialConfThresh = ThreshConf,
                            singleTrialConfTrial = ConfTrial,
                        });

                        //////////////////////////////////////////RL
                        await InvokeAsync(StateHasChanged);

                        ////prime
                        //singleTrialCycle.Add(c);

                        //asoLine1Cycle0y.Add(outbLX[0]);
                        await Task.Delay(1);



                        //asoLine1Cycle1y.Add(outbLX[1]);



                        //asoLine1Cycle2y.Add(outbLX[2]);

                        ////target

                        //asoLine2Cycle0y.Add(outbRX[0]);



                        //asoLine2Cycle1y.Add(outbRX[1]);



                        //asoLine2Cycle2y.Add(outbRX[2]);

                        /////////////////////////////////////motor/out


                        //asoLine3Cycle0y.Add(outaX[0]);



                        //asoLine3Cycle1y.Add(outaX[1]);



                        //asoLine3Cycle2y.Add(ThreshO);

                        //////////////////////////////////////////task



                        //asoLine4Cycle0y.Add(taskX[0]);



                        //asoLine4Cycle1y.Add(taskX[1]);


                        //asoLine4Cycle2y.Add(ThreshT);


                        //////////////////////////////////////////att



                        //asoLine5Cycle0y.Add(v);


                        //asoLine5Cycle1y.Add(u);


                        //asoLine5Cycle2y.Add(hv);


                        ////////////////////////////////////////////conf

                        //asoLine6Cycle0y.Add(Conf);

                        //asoLine6Cycle1y.Add(ThreshConf);

                        //asoLine6Cycle2y.Add(ConfTrial);
                    }

                    singleTrialArray = singleTrialList.ToArray();

                }  //for loop c ////////////////////////////////......---------------->>>>>>>>>>>>>>>>>>


                // for (i=0;i< double.Parse(Text1TrialsNumber.Text); i++)
                //{
                //  rtMeanIC1 = rtMeanIC1 + rtMeanIC[i];
                //}
                //TextBoxMultiLine.AppendText ("rt="+(rtMeanIC1/ double.Parse(Text1TrialsNumber.Text)).ToString()+Environment.NewLine);

                //Application.DoEvents();
                //}

                if (rt > 0)
                {
                    //rt = rt - durMaskTargetISI;
                    if (ic == 1)
                    {
                        rtSumC += rt;
                        rtMeanC = rtSumC / rtC;
                        rtC++;
                        TrialsStr1 = TrialsStr1 + "c" + ";" + rt.ToString() + ",";
                        // TextBoxMultiLine.AppendText(nnew.ToString() + "rtC=" + (rtMeanC / rtC).ToString() + Environment.NewLine);
                        //Jobs.Add(new JobDto { Id = n, Description = ic.ToString(), Status = JobStatuses.Running, RT_MeanC = rtMeanC });

                    }
                    else
                    {

                        rtSumI += rt;
                        rtMeanI = rtSumI / rtI;
                        rtI++;
                        TrialsStr1 = TrialsStr1 + "i" + ";" + rt.ToString() + ",";
                        //rt -= rtMeanI;
                        //TextBoxMultiLine.AppendText(nnew.ToString() + "rtI=" + (rtMeanI / rtI).ToString() + Environment.NewLine);

                        //Jobs.Add(new JobDto { Id = n, Description = ic.ToString(), Status = JobStatuses.Completed,  RT_MeanI = rtMeanI  });

                    }
                }

                //pointsInpModelsI_C[m] = new Point { X = m, Y = rtMeanI - rtMeanC };






                //chartIC.Series["IC"].Points.AddXY(nnew, rtMeanI / rtI - rtMeanC / rtC);
                //chartIC.Series["G"].Points.AddXY(nnew, rt - 650);

                //ChartConflict.Series["T"].Points.AddXY(c, 0);
                //ChartConflict.Series["G"].Points.AddXY(c, 0);

                // trialsRTarray[n].cycleX=n;
                // trialsRTarray[n].trialRT=Convert.ToDouble(rt);

                trialsRTlist.Add(new trialDataItem
                {
                    trialCycleX = (n + 1).ToString(),
                    // Date = DateTime.Parse("2020-03-01"),
                    trialRT = rt

                });

                trialsRTarray = trialsRTlist.ToArray();
                // revenue20192 = trialsRTlist.ToArray();


                mProgress = Convert.ToDouble(Convert.ToInt32((Convert.ToDouble(n + 1) / TrialCount) * 100));

                await Task.Delay(1); // 1 second delay

                await InvokeAsync(StateHasChanged);


                //nTotal++;
            } //for loop n.//////////////////.........>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


            modelsRTlist.Add(new modelDataItem
            {
                modelCycleX = (m + 1).ToString(),
                // Date = DateTime.Parse("2020-03-01"),
                modelRTc = rtMeanC,
                modelRTi = rtMeanI,

                modelRTic = (rtMeanI - rtMeanC) * 10,
                TrialsStr = TrialsStr1,


            });

            modelsRTarray = modelsRTlist.ToArray();



            // for (int i = 0; i < pointsInpModelsC.Length; i++)
            // {

            //aso var /////////////////
            // await Task.Delay(1); // 1 second delay




            //asoTimeElapsed = stopwatch.ElapsedMilliseconds;
            //stopwatch.Stop();

            // if (spinning == true)
            // {
            //               await InvokeAsync(StateHasChanged);
            //mm = Convert.ToDouble(m);

            //ModelsIC[m, 0] = rtMeanC;
            //ModelsIC[m, 1] = rtMeanI;


            //pointsInpModelsC[m] = new Point { X = m, Y = rtMeanC - durMaskTargetISI };
            //pointsInpModelsI[m] = new Point { X = m, Y = rtMeanI - durMaskTargetISI };

            // pointsInpModelsI_C[m] = new Point { X = m, Y = rtMeanI - rtMeanC };

            //  ModelsData.Add(new Models
            // {
            //     No = m + 1,
            //     RTincong = rtMeanI,
            //     RTcong = rtMeanC,
            //     TrialsStr = TrialsStr1,

            // });

            // mProgress = (Convert.ToDouble(m + 1) / ModelCount) * 100;






            //await InvokeAsync(StateHasChanged);


        } //for loop m.................>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!!!!!!!!!!!!!!!!!!!!!>>>>>>>>>>
        spinning = false;
        await Task.Delay(1);
        await InvokeAsync(StateHasChanged);



        // return rt; ///->result
    }

    static Random rnd = new Random();

    public double Draw(double noi)
    {
        while (true)
        {
            // Get random values from interval [0,1]
            var xme = rnd.NextDouble();
            //Task.Delay(1).Wait();

            var yme = rnd.NextDouble();

            // Is the point (x,y) under the curve of the density function?
            if (yme < f(xme, 0.0, noi))
                return xme;
        }
    }



    public double f(double xme, double μ, double σ)
    {
        return 1d / Math.Sqrt(2 * σ * σ * Math.PI) * Math.Exp(-((xme - μ) * (xme - μ)) / (2 * σ * σ));
    }



}
